/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpreplay_edit_opts.c)
 *  
 *  It has been AutoGen-ed  November 28, 2013 at 09:14:58 AM by AutoGen 5.10
 *  From the definitions    tcpreplay_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 33:0:8 templates.
 */

/*
 *  This file was produced by an AutoOpts template.  AutoOpts is a
 *  copyrighted work.  This source file is not encumbered by AutoOpts
 *  licensing, but is provided under the licensing terms chosen by the
 *  tcpreplay-edit author or copyright holder.  AutoOpts is licensed under
 *  the terms of the LGPL.  The redistributable library (``libopts'') is
 *  licensed under the terms of either the LGPL or, at the users discretion,
 *  the BSD license.  See the AutoOpts and/or libopts sources for details.
 *
 * This source file is copyrighted and licensed under the following terms:
 *
 * tcpreplay-edit copyright (c) 2000-2010 Aaron Turner - all rights reserved
 *
 * tcpreplay-edit is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * tcpreplay-edit is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <sys/types.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
extern FILE * option_usage_fp;
#define OPTION_CODE_COMPILE 1
#include "tcpreplay_edit_opts.h"

#ifdef  __cplusplus
extern "C" {
#endif

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
tSCC zCopyright[] =
       "tcpreplay-edit copyright (c) 2000-2010 Aaron Turner, all rights reserved";
tSCC zCopyrightNotice[616] =
"tcpreplay-edit is free software: you can redistribute it and/or modify it under\n\
the terms of the GNU General Public License as published by the Free Software\n\
Foundation, either version 3 of the License, or (at your option) any later\n\
version.\n\n\
tcpreplay-edit is distributed in the hope that it will be useful, but WITHOUT\n\
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n\
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\n\
You should have received a copy of the GNU General Public License along with\n\
this program.  If not, see <http://www.gnu.org/licenses/>.";

extern tUsageProc optionUsage;

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpreplay.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif

/*
 *  Tcpedit option description:
 */
tSCC    zTcpeditText[] =
        "";
#define TCPEDIT_FLAGS       (OPTST_DOCUMENT | OPTST_NO_INIT)

/*
 *  Portmap option description:
 */
tSCC    zPortmapText[] =
        "Rewrite TCP/UDP ports";
tSCC    zPortmap_NAME[]            = "PORTMAP";
tSCC    zPortmap_Name[]            = "portmap";
#define PORTMAP_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Seed option description:
 */
tSCC    zSeedText[] =
        "Randomize src/dst IPv4/v6 addresses w/ given seed";
tSCC    zSeed_NAME[]               = "SEED";
tSCC    zSeed_Name[]               = "seed";
#define SEED_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Pnat option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPnatText[] =
        "Rewrite IPv4/v6 addresses using pseudo-NAT";
tSCC    zPnat_NAME[]               = "PNAT";
tSCC    zPnat_Name[]               = "pnat";
static const int
    aPnatCantList[] = {
    INDEX_OPT_SRCIPMAP, NO_EQUIVALENT };
#define PNAT_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Srcipmap option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zSrcipmapText[] =
        "Rewrite source IPv4/v6 addresses using pseudo-NAT";
tSCC    zSrcipmap_NAME[]           = "SRCIPMAP";
tSCC    zSrcipmap_Name[]           = "srcipmap";
static const int
    aSrcipmapCantList[] = {
    INDEX_OPT_PNAT, NO_EQUIVALENT };
#define SRCIPMAP_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Dstipmap option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zDstipmapText[] =
        "Rewrite destination IPv4/v6 addresses using pseudo-NAT";
tSCC    zDstipmap_NAME[]           = "DSTIPMAP";
tSCC    zDstipmap_Name[]           = "dstipmap";
static const int
    aDstipmapCantList[] = {
    INDEX_OPT_PNAT, NO_EQUIVALENT };
#define DSTIPMAP_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Endpoints option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef HAVE_CACHEFILE_SUPPORT
tSCC    zEndpointsText[] =
        "Rewrite IP addresses to be between two endpoints";
tSCC    zEndpoints_NAME[]          = "ENDPOINTS";
tSCC    zEndpoints_Name[]          = "endpoints";
static const int
    aEndpointsMustList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define ENDPOINTS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Endpoints */
#define ENDPOINTS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define aEndpointsMustList   NULL
#define zEndpoints_NAME      NULL
#define zEndpointsText       NULL
#define zEndpoints_Name      NULL
#endif  /* HAVE_CACHEFILE_SUPPORT */

/*
 *  Skipbroadcast option description:
 */
tSCC    zSkipbroadcastText[] =
        "Skip rewriting broadcast/multicast IPv4/v6 addresses";
tSCC    zSkipbroadcast_NAME[]      = "SKIPBROADCAST";
tSCC    zSkipbroadcast_Name[]      = "skipbroadcast";
#define SKIPBROADCAST_FLAGS       (OPTST_DISABLED)

/*
 *  Fixcsum option description:
 */
tSCC    zFixcsumText[] =
        "Force recalculation of IPv4/TCP/UDP header checksums";
tSCC    zFixcsum_NAME[]            = "FIXCSUM";
tSCC    zFixcsum_Name[]            = "fixcsum";
#define FIXCSUM_FLAGS       (OPTST_DISABLED)

/*
 *  Mtu option description:
 */
tSCC    zMtuText[] =
        "Override default MTU length (1500 bytes)";
tSCC    zMtu_NAME[]                = "MTU";
tSCC    zMtu_Name[]                = "mtu";
#define MTU_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Mtu_Trunc option description:
 */
tSCC    zMtu_TruncText[] =
        "Truncate packets larger then specified MTU";
tSCC    zMtu_Trunc_NAME[]          = "MTU_TRUNC";
tSCC    zMtu_Trunc_Name[]          = "mtu-trunc";
#define MTU_TRUNC_FLAGS       (OPTST_DISABLED)

/*
 *  Efcs option description:
 */
tSCC    zEfcsText[] =
        "Remove Ethernet checksums (FCS) from end of frames";
tSCC    zEfcs_NAME[]               = "EFCS";
tSCC    zEfcs_Name[]               = "efcs";
#define EFCS_FLAGS       (OPTST_DISABLED)

/*
 *  Ttl option description:
 */
tSCC    zTtlText[] =
        "Modify the IPv4/v6 TTL/Hop Limit";
tSCC    zTtl_NAME[]                = "TTL";
tSCC    zTtl_Name[]                = "ttl";
#define TTL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Tos option description:
 */
tSCC    zTosText[] =
        "Set the IPv4 TOS/DiffServ/ECN byte";
tSCC    zTos_NAME[]                = "TOS";
tSCC    zTos_Name[]                = "tos";
#define TOS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Tclass option description:
 */
tSCC    zTclassText[] =
        "Set the IPv6 Traffic Class byte";
tSCC    zTclass_NAME[]             = "TCLASS";
tSCC    zTclass_Name[]             = "tclass";
#define TCLASS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Flowlabel option description:
 */
tSCC    zFlowlabelText[] =
        "Set the IPv6 Flow Label";
tSCC    zFlowlabel_NAME[]          = "FLOWLABEL";
tSCC    zFlowlabel_Name[]          = "flowlabel";
#define FLOWLABEL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Fixlen option description:
 */
tSCC    zFixlenText[] =
        "Pad or truncate packet data to match header length";
tSCC    zFixlen_NAME[]             = "FIXLEN";
tSCC    zFixlen_Name[]             = "fixlen";
#define FIXLEN_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Skipl2broadcast option description:
 */
tSCC    zSkipl2broadcastText[] =
        "Skip rewriting broadcast/multicast Layer 2 addresses";
tSCC    zSkipl2broadcast_NAME[]    = "SKIPL2BROADCAST";
tSCC    zSkipl2broadcast_Name[]    = "skipl2broadcast";
#define SKIPL2BROADCAST_FLAGS       (OPTST_DISABLED)

/*
 *  Dlt option description:
 */
tSCC    zDltText[] =
        "Override output DLT encapsulation";
tSCC    zDlt_NAME[]                = "DLT";
tSCC    zDlt_Name[]                = "dlt";
#define DLT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Enet_Dmac option description:
 */
tSCC    zEnet_DmacText[] =
        "Override destination ethernet MAC addresses";
tSCC    zEnet_Dmac_NAME[]          = "ENET_DMAC";
tSCC    zEnet_Dmac_Name[]          = "enet-dmac";
#define ENET_DMAC_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Enet_Smac option description:
 */
tSCC    zEnet_SmacText[] =
        "Override source ethernet MAC addresses";
tSCC    zEnet_Smac_NAME[]          = "ENET_SMAC";
tSCC    zEnet_Smac_Name[]          = "enet-smac";
#define ENET_SMAC_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Enet_Vlan option description:
 */
tSCC    zEnet_VlanText[] =
        "Specify ethernet 802.1q VLAN tag mode";
tSCC    zEnet_Vlan_NAME[]          = "ENET_VLAN";
tSCC    zEnet_Vlan_Name[]          = "enet-vlan";
#define ENET_VLAN_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Enet_Vlan_Tag option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnet_Vlan_TagText[] =
        "Specify the new ethernet 802.1q VLAN tag value";
tSCC    zEnet_Vlan_Tag_NAME[]      = "ENET_VLAN_TAG";
tSCC    zEnet_Vlan_Tag_Name[]      = "enet-vlan-tag";
static const int
    aEnet_Vlan_TagMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_TAG_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Enet_Vlan_Cfi option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnet_Vlan_CfiText[] =
        "Specify the ethernet 802.1q VLAN CFI value";
tSCC    zEnet_Vlan_Cfi_NAME[]      = "ENET_VLAN_CFI";
tSCC    zEnet_Vlan_Cfi_Name[]      = "enet-vlan-cfi";
static const int
    aEnet_Vlan_CfiMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_CFI_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Enet_Vlan_Pri option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnet_Vlan_PriText[] =
        "Specify the ethernet 802.1q VLAN priority";
tSCC    zEnet_Vlan_Pri_NAME[]      = "ENET_VLAN_PRI";
tSCC    zEnet_Vlan_Pri_Name[]      = "enet-vlan-pri";
static const int
    aEnet_Vlan_PriMustList[] = {
    INDEX_OPT_ENET_VLAN, NO_EQUIVALENT };
#define ENET_VLAN_PRI_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Hdlc_Control option description:
 */
tSCC    zHdlc_ControlText[] =
        "Specify HDLC control value";
tSCC    zHdlc_Control_NAME[]       = "HDLC_CONTROL";
tSCC    zHdlc_Control_Name[]       = "hdlc-control";
#define HDLC_CONTROL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Hdlc_Address option description:
 */
tSCC    zHdlc_AddressText[] =
        "Specify HDLC address";
tSCC    zHdlc_Address_NAME[]       = "HDLC_ADDRESS";
tSCC    zHdlc_Address_Name[]       = "hdlc-address";
#define HDLC_ADDRESS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  User_Dlt option description:
 */
tSCC    zUser_DltText[] =
        "Set output file DLT type";
tSCC    zUser_Dlt_NAME[]           = "USER_DLT";
tSCC    zUser_Dlt_Name[]           = "user-dlt";
#define USER_DLT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  User_Dlink option description:
 */
tSCC    zUser_DlinkText[] =
        "Rewrite Data-Link layer with user specified data";
tSCC    zUser_Dlink_NAME[]         = "USER_DLINK";
tSCC    zUser_Dlink_Name[]         = "user-dlink";
#define USER_DLINK_FLAGS       (OPTST_DISABLED | OPTST_STACKED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Dbug option description:
 */
#ifdef DEBUG
tSCC    zDbugText[] =
        "Enable debugging output";
tSCC    zDbug_NAME[]               = "DBUG";
tSCC    zDbug_Name[]               = "dbug";
#define zDbugDefaultArg              ((char const*)0)
#define DBUG_FLAGS       (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable Dbug */
#define DBUG_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zDbugDefaultArg NULL
#define zDbug_NAME      NULL
#define zDbugText       NULL
#define zDbug_Name      NULL
#endif  /* DEBUG */

/*
 *  Quiet option description:
 */
tSCC    zQuietText[] =
        "Quiet mode";
tSCC    zQuiet_NAME[]              = "QUIET";
tSCC    zQuiet_Name[]              = "quiet";
#define QUIET_FLAGS       (OPTST_DISABLED)

/*
 *  Timer option description:
 */
tSCC    zTimerText[] =
        "Select packet timing mode: select, ioport, rdtsc, gtod, nano, abstime";
tSCC    zTimer_NAME[]              = "TIMER";
tSCC    zTimer_Name[]              = "timer";
tSCC    zTimerDefaultArg[]           = "gtod";
#define TIMER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Sleep_Accel option description:
 */
tSCC    zSleep_AccelText[] =
        "Reduce the amount of time to sleep by specified usec";
tSCC    zSleep_Accel_NAME[]        = "SLEEP_ACCEL";
tSCC    zSleep_Accel_Name[]        = "sleep-accel";
#define zSleep_AccelDefaultArg       ((char const*)0)
#define SLEEP_ACCEL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Rdtsc_Clicks option description:
 */
tSCC    zRdtsc_ClicksText[] =
        "Specify the RDTSC clicks/usec";
tSCC    zRdtsc_Clicks_NAME[]       = "RDTSC_CLICKS";
tSCC    zRdtsc_Clicks_Name[]       = "rdtsc-clicks";
#define zRdtsc_ClicksDefaultArg      ((char const*)0)
#define RDTSC_CLICKS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Verbose option description:
 */
#ifdef ENABLE_VERBOSE
tSCC    zVerboseText[] =
        "Print decoded packets via tcpdump to STDOUT";
tSCC    zVerbose_NAME[]            = "VERBOSE";
tSCC    zVerbose_Name[]            = "verbose";
#define VERBOSE_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Verbose */
#define VERBOSE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zVerbose_NAME      NULL
#define zVerboseText       NULL
#define zVerbose_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
tSCC    zDecodeText[] =
        "Arguments passed to tcpdump decoder";
tSCC    zDecode_NAME[]             = "DECODE";
tSCC    zDecode_Name[]             = "decode";
static const int
    aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Decode */
#define DECODE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define zDecode_NAME      NULL
#define zDecodeText       NULL
#define zDecode_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Enable_File_Cache option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnable_File_CacheText[] =
        "Enable caching of packets to internal memory";
tSCC    zEnable_File_Cache_NAME[]  = "ENABLE_FILE_CACHE";
tSCC    zEnable_File_Cache_Name[]  = "enable-file-cache";
static const int
    aEnable_File_CacheMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
#define ENABLE_FILE_CACHE_FLAGS       (OPTST_DISABLED)

/*
 *  Preload_Pcap option description:
 */
tSCC    zPreload_PcapText[] =
        "Preloads packets into RAM before sending";
tSCC    zPreload_Pcap_NAME[]       = "PRELOAD_PCAP";
tSCC    zPreload_Pcap_Name[]       = "preload-pcap";
#define PRELOAD_PCAP_FLAGS       (OPTST_DISABLED)

/*
 *  Cachefile option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zCachefileText[] =
        "Split traffic via a tcpprep cache file";
tSCC    zCachefile_NAME[]          = "CACHEFILE";
tSCC    zCachefile_Name[]          = "cachefile";
static const int
    aCachefileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static const int
    aCachefileCantList[] = {
    INDEX_OPT_DUALFILE, NO_EQUIVALENT };
#define CACHEFILE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Dualfile option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zDualfileText[] =
        "Replay two files at a time from a network tap";
tSCC    zDualfile_NAME[]           = "DUALFILE";
tSCC    zDualfile_Name[]           = "dualfile";
static const int
    aDualfileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static const int
    aDualfileCantList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define DUALFILE_FLAGS       (OPTST_DISABLED)

/*
 *  Intf1 option description:
 */
tSCC    zIntf1Text[] =
        "Server/primary traffic output interface";
tSCC    zIntf1_NAME[]              = "INTF1";
tSCC    zIntf1_Name[]              = "intf1";
#define INTF1_FLAGS       (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Intf2 option description:
 */
tSCC    zIntf2Text[] =
        "Client/secondary traffic output interface";
tSCC    zIntf2_NAME[]              = "INTF2";
tSCC    zIntf2_Name[]              = "intf2";
#define INTF2_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
tSCC    zListnicsText[] =
        "List available network interfaces and exit";
tSCC    zListnics_NAME[]           = "LISTNICS";
tSCC    zListnics_Name[]           = "listnics";
#define LISTNICS_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Listnics */
#define LISTNICS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zListnics_NAME      NULL
#define zListnicsText       NULL
#define zListnics_Name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/*
 *  Loop option description:
 */
tSCC    zLoopText[] =
        "Loop through the capture file X times";
tSCC    zLoop_NAME[]               = "LOOP";
tSCC    zLoop_Name[]               = "loop";
#define zLoopDefaultArg              ((char const*)1)
#define LOOP_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Pktlen option description:
 */
tSCC    zPktlenText[] =
        "Override the snaplen and use the actual packet len";
tSCC    zPktlen_NAME[]             = "PKTLEN";
tSCC    zPktlen_Name[]             = "pktlen";
#define PKTLEN_FLAGS       (OPTST_DISABLED)

/*
 *  Limit option description:
 */
tSCC    zLimitText[] =
        "Limit the number of packets to send";
tSCC    zLimit_NAME[]              = "LIMIT";
tSCC    zLimit_Name[]              = "limit";
#define zLimitDefaultArg             ((char const*)-1)
#define LIMIT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Multiplier option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMultiplierText[] =
        "Modify replay speed to a given multiple";
tSCC    zMultiplier_NAME[]         = "MULTIPLIER";
tSCC    zMultiplier_Name[]         = "multiplier";
static const int
    aMultiplierCantList[] = {
    INDEX_OPT_PPS,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MULTIPLIER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Pps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPpsText[] =
        "Replay packets at a given packets/sec";
tSCC    zPps_NAME[]                = "PPS";
tSCC    zPps_Name[]                = "pps";
static const int
    aPpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define PPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Mbps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMbpsText[] =
        "Replay packets at a given Mbps";
tSCC    zMbps_NAME[]               = "MBPS";
tSCC    zMbps_Name[]               = "mbps";
static const int
    aMbpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MBPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Topspeed option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zTopspeedText[] =
        "Replay packets as fast as possible";
tSCC    zTopspeed_NAME[]           = "TOPSPEED";
tSCC    zTopspeed_Name[]           = "topspeed";
static const int
    aTopspeedCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME, NO_EQUIVALENT };
#define TOPSPEED_FLAGS       (OPTST_DISABLED)

/*
 *  Oneatatime option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zOneatatimeText[] =
        "Replay one packet at a time for each user input";
tSCC    zOneatatime_NAME[]         = "ONEATATIME";
tSCC    zOneatatime_Name[]         = "oneatatime";
static const int
    aOneatatimeCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_PPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define ONEATATIME_FLAGS       (OPTST_DISABLED)

/*
 *  Pps_Multi option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPps_MultiText[] =
        "Number of packets to send for each time interval";
tSCC    zPps_Multi_NAME[]          = "PPS_MULTI";
tSCC    zPps_Multi_Name[]          = "pps-multi";
#define zPps_MultiDefaultArg         ((char const*)1)
static const int
    aPps_MultiMustList[] = {
    INDEX_OPT_PPS, NO_EQUIVALENT };
#define PPS_MULTI_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Netmap option description:
 */
tSCC    zNetmapText[] =
        "Write packets directly to netmap enabled network adapter";
tSCC    zNetmap_NAME[]             = "NETMAP";
tSCC    zNetmap_Name[]             = "netmap";
#define NETMAP_FLAGS       (OPTST_DISABLED)

/*
 *  Pid option description:
 */
tSCC    zPidText[] =
        "Print the PID of tcpreplay at startup";
tSCC    zPid_NAME[]                = "PID";
tSCC    zPid_Name[]                = "pid";
#define PID_FLAGS       (OPTST_DISABLED)

/*
 *  Stats option description:
 */
tSCC    zStatsText[] =
        "Print statistics every X seconds";
tSCC    zStats_NAME[]              = "STATS";
tSCC    zStats_Name[]              = "stats";
#define STATS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Version option description:
 */
tSCC    zVersionText[] =
        "Print version information";
tSCC    zVersion_NAME[]            = "VERSION";
tSCC    zVersion_Name[]            = "version";
#define VERSION_FLAGS       (OPTST_DISABLED)

/*
 *  Less_Help option description:
 */
tSCC    zLess_HelpText[] =
        "Display less usage information and exit";
tSCC    zLess_Help_NAME[]          = "LESS_HELP";
tSCC    zLess_Help_Name[]          = "less-help";
#define LESS_HELP_FLAGS       (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
tSCC zHelpText[]          = "Display extended usage information and exit";
tSCC zHelp_Name[]         = "help";
#ifdef HAVE_WORKING_FORK
#define OPTST_MORE_HELP_FLAGS   (OPTST_IMM | OPTST_NO_INIT)
tSCC zMore_Help_Name[]    = "more-help";
tSCC zMore_HelpText[]     = "Extended usage information passed thru pager";
#else
#define OPTST_MORE_HELP_FLAGS   (OPTST_OMITTED | OPTST_NO_INIT)
#define zMore_Help_Name   NULL
#define zMore_HelpText    NULL
#endif
tSCC zSave_OptsText[]     = "Save the option state to a config file";
tSCC zSave_Opts_Name[]    = "save-opts";
tSCC zLoad_OptsText[]     = "Load options from a config file";
tSCC zLoad_Opts_NAME[]    = "LOAD_OPTS";
tSCC zNotLoad_Opts_Name[] = "no-load-opts";
tSCC zNotLoad_Opts_Pfx[]  = "no";
#define zLoad_Opts_Name   (zNotLoad_Opts_Name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionNumericVal, optionPagedUsage, optionStackArg;
static tOptProc
    doOptEnet_Vlan_Cfi, doOptEnet_Vlan_Pri, doOptEnet_Vlan_Tag,
    doOptFlowlabel,     doOptLess_Help,     doOptLimit,
    doOptLoop,          doOptMtu,           doOptPid,
    doOptPps_Multi,     doOptStats,         doOptTclass,
    doOptTos,           doOptVersion,       doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay_Edit Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, 0,
     /* equiv idx, value */ 0, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 0, 0,
     /* opt state flags  */ TCPEDIT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTcpeditText, NULL, NULL,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_PORTMAP,
     /* equiv idx, value */ 1, VALUE_OPT_PORTMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, -1, 0,
     /* opt state flags  */ PORTMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zPortmapText, zPortmap_NAME, zPortmap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_SEED,
     /* equiv idx, value */ 2, VALUE_OPT_SEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SEED_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zSeedText, zSeed_NAME, zSeed_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_PNAT,
     /* equiv idx, value */ 3, VALUE_OPT_PNAT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 2, 0,
     /* opt state flags  */ PNAT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPnatCantList,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zPnatText, zPnat_NAME, zPnat_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_SRCIPMAP,
     /* equiv idx, value */ 4, VALUE_OPT_SRCIPMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SRCIPMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aSrcipmapCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSrcipmapText, zSrcipmap_NAME, zSrcipmap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_DSTIPMAP,
     /* equiv idx, value */ 5, VALUE_OPT_DSTIPMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DSTIPMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aDstipmapCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDstipmapText, zDstipmap_NAME, zDstipmap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_ENDPOINTS,
     /* equiv idx, value */ 6, VALUE_OPT_ENDPOINTS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENDPOINTS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEndpointsMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEndpointsText, zEndpoints_NAME, zEndpoints_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_SKIPBROADCAST,
     /* equiv idx, value */ 7, VALUE_OPT_SKIPBROADCAST,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SKIPBROADCAST_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSkipbroadcastText, zSkipbroadcast_NAME, zSkipbroadcast_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_FIXCSUM,
     /* equiv idx, value */ 8, VALUE_OPT_FIXCSUM,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FIXCSUM_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zFixcsumText, zFixcsum_NAME, zFixcsum_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_MTU,
     /* equiv idx, value */ 9, VALUE_OPT_MTU,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MTU_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptMtu,
     /* desc, NAME, name */ zMtuText, zMtu_NAME, zMtu_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_MTU_TRUNC,
     /* equiv idx, value */ 10, VALUE_OPT_MTU_TRUNC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MTU_TRUNC_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMtu_TruncText, zMtu_Trunc_NAME, zMtu_Trunc_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_EFCS,
     /* equiv idx, value */ 11, VALUE_OPT_EFCS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ EFCS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEfcsText, zEfcs_NAME, zEfcs_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_TTL,
     /* equiv idx, value */ 12, VALUE_OPT_TTL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TTL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTtlText, zTtl_NAME, zTtl_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_TOS,
     /* equiv idx, value */ 13, VALUE_OPT_TOS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTos,
     /* desc, NAME, name */ zTosText, zTos_NAME, zTos_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_TCLASS,
     /* equiv idx, value */ 14, VALUE_OPT_TCLASS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TCLASS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptTclass,
     /* desc, NAME, name */ zTclassText, zTclass_NAME, zTclass_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_FLOWLABEL,
     /* equiv idx, value */ 15, VALUE_OPT_FLOWLABEL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FLOWLABEL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptFlowlabel,
     /* desc, NAME, name */ zFlowlabelText, zFlowlabel_NAME, zFlowlabel_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_FIXLEN,
     /* equiv idx, value */ 16, VALUE_OPT_FIXLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ FIXLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zFixlenText, zFixlen_NAME, zFixlen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_SKIPL2BROADCAST,
     /* equiv idx, value */ 17, VALUE_OPT_SKIPL2BROADCAST,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SKIPL2BROADCAST_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSkipl2broadcastText, zSkipl2broadcast_NAME, zSkipl2broadcast_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_DLT,
     /* equiv idx, value */ 18, VALUE_OPT_DLT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DLT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDltText, zDlt_NAME, zDlt_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_ENET_DMAC,
     /* equiv idx, value */ 19, VALUE_OPT_ENET_DMAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_DMAC_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnet_DmacText, zEnet_Dmac_NAME, zEnet_Dmac_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_ENET_SMAC,
     /* equiv idx, value */ 20, VALUE_OPT_ENET_SMAC,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_SMAC_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnet_SmacText, zEnet_Smac_NAME, zEnet_Smac_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_ENET_VLAN,
     /* equiv idx, value */ 21, VALUE_OPT_ENET_VLAN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnet_VlanText, zEnet_Vlan_NAME, zEnet_Vlan_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_ENET_VLAN_TAG,
     /* equiv idx, value */ 22, VALUE_OPT_ENET_VLAN_TAG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_TAG_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_TagMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Tag,
     /* desc, NAME, name */ zEnet_Vlan_TagText, zEnet_Vlan_Tag_NAME, zEnet_Vlan_Tag_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_ENET_VLAN_CFI,
     /* equiv idx, value */ 23, VALUE_OPT_ENET_VLAN_CFI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_CFI_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_CfiMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Cfi,
     /* desc, NAME, name */ zEnet_Vlan_CfiText, zEnet_Vlan_Cfi_NAME, zEnet_Vlan_Cfi_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_ENET_VLAN_PRI,
     /* equiv idx, value */ 24, VALUE_OPT_ENET_VLAN_PRI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENET_VLAN_PRI_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnet_Vlan_PriMustList, NULL,
     /* option proc      */ doOptEnet_Vlan_Pri,
     /* desc, NAME, name */ zEnet_Vlan_PriText, zEnet_Vlan_Pri_NAME, zEnet_Vlan_Pri_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 25, VALUE_OPT_HDLC_CONTROL,
     /* equiv idx, value */ 25, VALUE_OPT_HDLC_CONTROL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ HDLC_CONTROL_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zHdlc_ControlText, zHdlc_Control_NAME, zHdlc_Control_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 26, VALUE_OPT_HDLC_ADDRESS,
     /* equiv idx, value */ 26, VALUE_OPT_HDLC_ADDRESS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ HDLC_ADDRESS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zHdlc_AddressText, zHdlc_Address_NAME, zHdlc_Address_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 27, VALUE_OPT_USER_DLT,
     /* equiv idx, value */ 27, VALUE_OPT_USER_DLT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ USER_DLT_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zUser_DltText, zUser_Dlt_NAME, zUser_Dlt_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 28, VALUE_OPT_USER_DLINK,
     /* equiv idx, value */ 28, VALUE_OPT_USER_DLINK,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 2, 0,
     /* opt state flags  */ USER_DLINK_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionStackArg,
     /* desc, NAME, name */ zUser_DlinkText, zUser_Dlink_NAME, zUser_Dlink_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 29, VALUE_OPT_DBUG,
     /* equiv idx, value */ 29, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { zDbugDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ zDbugText, zDbug_NAME, zDbug_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 30, VALUE_OPT_QUIET,
     /* equiv idx, value */ 30, VALUE_OPT_QUIET,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUIET_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zQuietText, zQuiet_NAME, zQuiet_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 31, VALUE_OPT_TIMER,
     /* equiv idx, value */ 31, VALUE_OPT_TIMER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMER_FLAGS, 0,
     /* last opt argumnt */ { zTimerDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTimerText, zTimer_NAME, zTimer_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 32, VALUE_OPT_SLEEP_ACCEL,
     /* equiv idx, value */ 32, VALUE_OPT_SLEEP_ACCEL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SLEEP_ACCEL_FLAGS, 0,
     /* last opt argumnt */ { zSleep_AccelDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zSleep_AccelText, zSleep_Accel_NAME, zSleep_Accel_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 33, VALUE_OPT_RDTSC_CLICKS,
     /* equiv idx, value */ 33, VALUE_OPT_RDTSC_CLICKS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ RDTSC_CLICKS_FLAGS, 0,
     /* last opt argumnt */ { zRdtsc_ClicksDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zRdtsc_ClicksText, zRdtsc_Clicks_NAME, zRdtsc_Clicks_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 34, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 34, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zVerboseText, zVerbose_NAME, zVerbose_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 35, VALUE_OPT_DECODE,
     /* equiv idx, value */ 35, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDecodeText, zDecode_NAME, zDecode_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 36, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equiv idx, value */ 36, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENABLE_FILE_CACHE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnable_File_CacheMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnable_File_CacheText, zEnable_File_Cache_NAME, zEnable_File_Cache_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 37, VALUE_OPT_PRELOAD_PCAP,
     /* equiv idx, value */ 37, VALUE_OPT_PRELOAD_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRELOAD_PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPreload_PcapText, zPreload_Pcap_NAME, zPreload_Pcap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 38, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 38, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aCachefileMustList, aCachefileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zCachefileText, zCachefile_NAME, zCachefile_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 39, VALUE_OPT_DUALFILE,
     /* equiv idx, value */ 39, VALUE_OPT_DUALFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DUALFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDualfileMustList, aDualfileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDualfileText, zDualfile_NAME, zDualfile_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 40, VALUE_OPT_INTF1,
     /* equiv idx, value */ 40, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf1Text, zIntf1_NAME, zIntf1_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 41, VALUE_OPT_INTF2,
     /* equiv idx, value */ 41, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf2Text, zIntf2_NAME, zIntf2_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 42, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 42, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ zListnicsText, zListnics_NAME, zListnics_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 43, VALUE_OPT_LOOP,
     /* equiv idx, value */ 43, VALUE_OPT_LOOP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_FLAGS, 0,
     /* last opt argumnt */ { zLoopDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop,
     /* desc, NAME, name */ zLoopText, zLoop_NAME, zLoop_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 44, VALUE_OPT_PKTLEN,
     /* equiv idx, value */ 44, VALUE_OPT_PKTLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PKTLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPktlenText, zPktlen_NAME, zPktlen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 45, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 45, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { zLimitDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ zLimitText, zLimit_NAME, zLimit_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 46, VALUE_OPT_MULTIPLIER,
     /* equiv idx, value */ 46, VALUE_OPT_MULTIPLIER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MULTIPLIER_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMultiplierCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMultiplierText, zMultiplier_NAME, zMultiplier_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 47, VALUE_OPT_PPS,
     /* equiv idx, value */ 47, VALUE_OPT_PPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPpsCantList,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zPpsText, zPps_NAME, zPps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 48, VALUE_OPT_MBPS,
     /* equiv idx, value */ 48, VALUE_OPT_MBPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MBPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMbpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMbpsText, zMbps_NAME, zMbps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 49, VALUE_OPT_TOPSPEED,
     /* equiv idx, value */ 49, VALUE_OPT_TOPSPEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOPSPEED_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aTopspeedCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTopspeedText, zTopspeed_NAME, zTopspeed_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 50, VALUE_OPT_ONEATATIME,
     /* equiv idx, value */ 50, VALUE_OPT_ONEATATIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ONEATATIME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aOneatatimeCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zOneatatimeText, zOneatatime_NAME, zOneatatime_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 51, VALUE_OPT_PPS_MULTI,
     /* equiv idx, value */ 51, VALUE_OPT_PPS_MULTI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_MULTI_FLAGS, 0,
     /* last opt argumnt */ { zPps_MultiDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aPps_MultiMustList, NULL,
     /* option proc      */ doOptPps_Multi,
     /* desc, NAME, name */ zPps_MultiText, zPps_Multi_NAME, zPps_Multi_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 52, VALUE_OPT_NETMAP,
     /* equiv idx, value */ 52, VALUE_OPT_NETMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NETMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zNetmapText, zNetmap_NAME, zNetmap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 53, VALUE_OPT_PID,
     /* equiv idx, value */ 53, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ zPidText, zPid_NAME, zPid_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 54, VALUE_OPT_STATS,
     /* equiv idx, value */ 54, VALUE_OPT_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptStats,
     /* desc, NAME, name */ zStatsText, zStats_NAME, zStats_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 55, VALUE_OPT_VERSION,
     /* equiv idx, value */ 55, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ zVersionText, zVersion_NAME, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 56, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 56, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ zLess_HelpText, zLess_Help_NAME, zLess_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSave_OptsText, NULL, zSave_Opts_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ zLoad_OptsText, zLoad_Opts_NAME, zLoad_Opts_Name,
     /* disablement strs */ zNotLoad_Opts_Name, zNotLoad_Opts_Pfx }
};
tOptDesc * const tcpedit_tcpedit_optDesc_p = optDesc + 0;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay_Edit Option Environment
 */
tSCC   zPROGNAME[]   = "TCPREPLAY_EDIT";
tSCC   zUsageTitle[] =
"tcpreplay-edit (tcpreplay) - Replay network traffic stored in pcap files\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... \\\n\
\t\t<pcap_file(s)>\n";
tSCC   zRcName[]     = ".tcpreplay_editrc";
tSCC*  apzHomeList[] = {
       "$$/",
       NULL };

tSCC   zBugsAddr[]    = "tcpreplay-users@lists.sourceforge.net";
tSCC   zExplain[]     = "\n\
tcpreplay is a tool for replaying network traffic from files saved with\n\
tcpdump or other tools which write pcap(3) files.\n";
tSCC    zDetail[]     = "\n\
The basic operation of tcpreplay is to resend  all  packets  from  the\n\
input file(s) at the speed at which they were recorded, or a specified \n\
data rate, up to as fast as the hardware is capable.\n\n\
Optionally, the traffic can be split between two interfaces, written to\n\
files, filtered and edited in various ways, providing the means to test\n\
firewalls, NIDS and other network devices.\n\n\
For more details, please see the Tcpreplay Manual at:\n\
http://tcpreplay.synfin.net/wiki/manual\n";
#define zFullVersion    NULL
/* extracted from /usr/share/autogen/optcode.tpl near line 495 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpreplay_edit_full_usage NULL
#define tcpreplay_edit_short_usage NULL
tOptions tcpreplay_editOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_ARGS_REQ
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zCopyrightNotice,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage,       /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      9 /* index of default opt */
    },
    61 /* full option count */, 57 /* user option count */,
    tcpreplay_edit_full_usage, tcpreplay_edit_short_usage,
    NULL, NULL
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    (void)pOptions;
    USAGE( EXIT_SUCCESS );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the mtu option.
 */
static void
doOptMtu(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, MAXPACKET } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the tos option.
 */
static void
doOptTos(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 255 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the tclass option.
 */
static void
doOptTclass(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 255 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the flowlabel option.
 */
static void
doOptFlowlabel(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 1048575 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the enet-vlan-tag option.
 */
static void
doOptEnet_Vlan_Tag(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 4095 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the enet-vlan-cfi option.
 */
static void
doOptEnet_Vlan_Cfi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 1 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the enet-vlan-pri option.
 */
static void
doOptEnet_Vlan_Pri(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 7 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the dbug option, when DEBUG is #define-d.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 5 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 312 */

    interface_list_t *list = get_interface_list();
    list_interfaces(list);
    free(list);
    exit(0);

}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the loop option.
 */
static void
doOptLoop(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the limit option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pps-multi option.
 */
static void
doOptPps_Multi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pid option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 478 */

    fprintf(stderr, "PID: %d\n", getpid());

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the stats option.
 */
static void
doOptStats(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the version option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 501 */

    fprintf(stderr, "tcpreplay version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2000-2010 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
#ifdef TCPREPLAY_EDIT
    fprintf(stderr, "Packet editing: enabled\n");
#else
    fprintf(stderr, "Packet editing: disabled\n");
#endif
#ifdef ENABLE_FRAGROUTE
    fprintf(stderr, "Fragroute engine: enabled\n");
#else
    fprintf(stderr, "Fragroute engine: disabled\n");
#endif
#ifdef HAVE_NETMAP
    fprintf(stderr, "Default injection method: %s\n", sendpacket_get_method());
    fprintf(stderr, "Optional injection method: netmap\n");
#else
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method());
#endif
    exit(0);

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the less-help option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 558 */

    USAGE(EXIT_FAILURE);

}
/* extracted from /usr/share/autogen/optcode.tpl near line 627 */

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(tcpreplay_editOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {

        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc* pOD = tcpreplay_editOptions.pOptDesc;
        char**    ppz = (char**)(void*)&(option_usage_text);
        int       ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        COERSION(pzCopyright);
        COERSION(pzCopyNotice);
        COERSION(pzFullVersion);
        COERSION(pzUsageTitle);
        COERSION(pzExplain);
        COERSION(pzDetail);
        option_usage_text.field_ct = 0;

        for (ix = tcpreplay_editOptions.optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((tcpreplay_editOptions.fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc* pOD = tcpreplay_editOptions.pOptDesc;
        int       ix;

        for (ix = tcpreplay_editOptions.optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpreplay_editOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpreplay_edit_opts.c ends here */
