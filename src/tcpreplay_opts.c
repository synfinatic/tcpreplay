/*   -*- buffer-read-only: t -*- vi: set ro:
 *  
 *  DO NOT EDIT THIS FILE   (tcpreplay_opts.c)
 *  
 *  It has been AutoGen-ed  November 28, 2013 at 09:14:57 AM by AutoGen 5.10
 *  From the definitions    tcpreplay_opts.def
 *  and the template file   options
 *
 * Generated from AutoOpts 33:0:8 templates.
 */

/*
 *  This file was produced by an AutoOpts template.  AutoOpts is a
 *  copyrighted work.  This source file is not encumbered by AutoOpts
 *  licensing, but is provided under the licensing terms chosen by the
 *  tcpreplay author or copyright holder.  AutoOpts is licensed under
 *  the terms of the LGPL.  The redistributable library (``libopts'') is
 *  licensed under the terms of either the LGPL or, at the users discretion,
 *  the BSD license.  See the AutoOpts and/or libopts sources for details.
 *
 * This source file is copyrighted and licensed under the following terms:
 *
 * tcpreplay copyright (c) 2000-2010 Aaron Turner - all rights reserved
 *
 * tcpreplay is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * tcpreplay is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <sys/types.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
extern FILE * option_usage_fp;
#define OPTION_CODE_COMPILE 1
#include "tcpreplay_opts.h"

#ifdef  __cplusplus
extern "C" {
#endif

/* TRANSLATORS: choose the translation for option names wisely because you
                cannot ever change your mind. */
tSCC zCopyright[] =
       "tcpreplay copyright (c) 2000-2010 Aaron Turner, all rights reserved";
tSCC zCopyrightNotice[606] =
"tcpreplay is free software: you can redistribute it and/or modify it under the\n\
terms of the GNU General Public License as published by the Free Software\n\
Foundation, either version 3 of the License, or (at your option) any later\n\
version.\n\n\
tcpreplay is distributed in the hope that it will be useful, but WITHOUT ANY\n\
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n\n\
You should have received a copy of the GNU General Public License along with\n\
this program.  If not, see <http://www.gnu.org/licenses/>.";

extern tUsageProc optionUsage;

/*
 *  global included definitions
 */
#include "defines.h"
#include "tcpreplay.h"
#include "common.h"
#include "config.h"
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>


#ifndef NULL
#  define NULL 0
#endif
#ifndef EXIT_SUCCESS
#  define  EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#  define  EXIT_FAILURE 1
#endif

/*
 *  Dbug option description:
 */
#ifdef DEBUG
tSCC    zDbugText[] =
        "Enable debugging output";
tSCC    zDbug_NAME[]               = "DBUG";
tSCC    zDbug_Name[]               = "dbug";
#define zDbugDefaultArg              ((char const*)0)
#define DBUG_FLAGS       (OPTST_DISABLED | OPTST_IMM \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

#else   /* disable Dbug */
#define DBUG_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zDbugDefaultArg NULL
#define zDbug_NAME      NULL
#define zDbugText       NULL
#define zDbug_Name      NULL
#endif  /* DEBUG */

/*
 *  Quiet option description:
 */
tSCC    zQuietText[] =
        "Quiet mode";
tSCC    zQuiet_NAME[]              = "QUIET";
tSCC    zQuiet_Name[]              = "quiet";
#define QUIET_FLAGS       (OPTST_DISABLED)

/*
 *  Timer option description:
 */
tSCC    zTimerText[] =
        "Select packet timing mode: select, ioport, rdtsc, gtod, nano, abstime";
tSCC    zTimer_NAME[]              = "TIMER";
tSCC    zTimer_Name[]              = "timer";
tSCC    zTimerDefaultArg[]           = "gtod";
#define TIMER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Sleep_Accel option description:
 */
tSCC    zSleep_AccelText[] =
        "Reduce the amount of time to sleep by specified usec";
tSCC    zSleep_Accel_NAME[]        = "SLEEP_ACCEL";
tSCC    zSleep_Accel_Name[]        = "sleep-accel";
#define zSleep_AccelDefaultArg       ((char const*)0)
#define SLEEP_ACCEL_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Rdtsc_Clicks option description:
 */
tSCC    zRdtsc_ClicksText[] =
        "Specify the RDTSC clicks/usec";
tSCC    zRdtsc_Clicks_NAME[]       = "RDTSC_CLICKS";
tSCC    zRdtsc_Clicks_Name[]       = "rdtsc-clicks";
#define zRdtsc_ClicksDefaultArg      ((char const*)0)
#define RDTSC_CLICKS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Verbose option description:
 */
#ifdef ENABLE_VERBOSE
tSCC    zVerboseText[] =
        "Print decoded packets via tcpdump to STDOUT";
tSCC    zVerbose_NAME[]            = "VERBOSE";
tSCC    zVerbose_Name[]            = "verbose";
#define VERBOSE_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Verbose */
#define VERBOSE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zVerbose_NAME      NULL
#define zVerboseText       NULL
#define zVerbose_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Decode option description with
 *  "Must also have options" and "Incompatible options":
 */
#ifdef ENABLE_VERBOSE
tSCC    zDecodeText[] =
        "Arguments passed to tcpdump decoder";
tSCC    zDecode_NAME[]             = "DECODE";
tSCC    zDecode_Name[]             = "decode";
static const int
    aDecodeMustList[] = {
    INDEX_OPT_VERBOSE, NO_EQUIVALENT };
#define DECODE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

#else   /* disable Decode */
#define DECODE_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define aDecodeMustList   NULL
#define zDecode_NAME      NULL
#define zDecodeText       NULL
#define zDecode_Name      NULL
#endif  /* ENABLE_VERBOSE */

/*
 *  Enable_File_Cache option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zEnable_File_CacheText[] =
        "Enable caching of packets to internal memory";
tSCC    zEnable_File_Cache_NAME[]  = "ENABLE_FILE_CACHE";
tSCC    zEnable_File_Cache_Name[]  = "enable-file-cache";
static const int
    aEnable_File_CacheMustList[] = {
    INDEX_OPT_LOOP, NO_EQUIVALENT };
#define ENABLE_FILE_CACHE_FLAGS       (OPTST_DISABLED)

/*
 *  Preload_Pcap option description:
 */
tSCC    zPreload_PcapText[] =
        "Preloads packets into RAM before sending";
tSCC    zPreload_Pcap_NAME[]       = "PRELOAD_PCAP";
tSCC    zPreload_Pcap_Name[]       = "preload-pcap";
#define PRELOAD_PCAP_FLAGS       (OPTST_DISABLED)

/*
 *  Cachefile option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zCachefileText[] =
        "Split traffic via a tcpprep cache file";
tSCC    zCachefile_NAME[]          = "CACHEFILE";
tSCC    zCachefile_Name[]          = "cachefile";
static const int
    aCachefileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static const int
    aCachefileCantList[] = {
    INDEX_OPT_DUALFILE, NO_EQUIVALENT };
#define CACHEFILE_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Dualfile option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zDualfileText[] =
        "Replay two files at a time from a network tap";
tSCC    zDualfile_NAME[]           = "DUALFILE";
tSCC    zDualfile_Name[]           = "dualfile";
static const int
    aDualfileMustList[] = {
    INDEX_OPT_INTF2, NO_EQUIVALENT };
static const int
    aDualfileCantList[] = {
    INDEX_OPT_CACHEFILE, NO_EQUIVALENT };
#define DUALFILE_FLAGS       (OPTST_DISABLED)

/*
 *  Intf1 option description:
 */
tSCC    zIntf1Text[] =
        "Server/primary traffic output interface";
tSCC    zIntf1_NAME[]              = "INTF1";
tSCC    zIntf1_Name[]              = "intf1";
#define INTF1_FLAGS       (OPTST_DISABLED | OPTST_MUST_SET \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Intf2 option description:
 */
tSCC    zIntf2Text[] =
        "Client/secondary traffic output interface";
tSCC    zIntf2_NAME[]              = "INTF2";
tSCC    zIntf2_Name[]              = "intf2";
#define INTF2_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Listnics option description:
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
tSCC    zListnicsText[] =
        "List available network interfaces and exit";
tSCC    zListnics_NAME[]           = "LISTNICS";
tSCC    zListnics_Name[]           = "listnics";
#define LISTNICS_FLAGS       (OPTST_DISABLED | OPTST_IMM)

#else   /* disable Listnics */
#define LISTNICS_FLAGS       (OPTST_OMITTED | OPTST_NO_INIT)
#define zListnics_NAME      NULL
#define zListnicsText       NULL
#define zListnics_Name      NULL
#endif  /* ENABLE_PCAP_FINDALLDEVS */

/*
 *  Loop option description:
 */
tSCC    zLoopText[] =
        "Loop through the capture file X times";
tSCC    zLoop_NAME[]               = "LOOP";
tSCC    zLoop_Name[]               = "loop";
#define zLoopDefaultArg              ((char const*)1)
#define LOOP_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Pktlen option description:
 */
tSCC    zPktlenText[] =
        "Override the snaplen and use the actual packet len";
tSCC    zPktlen_NAME[]             = "PKTLEN";
tSCC    zPktlen_Name[]             = "pktlen";
#define PKTLEN_FLAGS       (OPTST_DISABLED)

/*
 *  Limit option description:
 */
tSCC    zLimitText[] =
        "Limit the number of packets to send";
tSCC    zLimit_NAME[]              = "LIMIT";
tSCC    zLimit_Name[]              = "limit";
#define zLimitDefaultArg             ((char const*)-1)
#define LIMIT_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Multiplier option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMultiplierText[] =
        "Modify replay speed to a given multiple";
tSCC    zMultiplier_NAME[]         = "MULTIPLIER";
tSCC    zMultiplier_Name[]         = "multiplier";
static const int
    aMultiplierCantList[] = {
    INDEX_OPT_PPS,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MULTIPLIER_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Pps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPpsText[] =
        "Replay packets at a given packets/sec";
tSCC    zPps_NAME[]                = "PPS";
tSCC    zPps_Name[]                = "pps";
static const int
    aPpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_MBPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define PPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Mbps option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zMbpsText[] =
        "Replay packets at a given Mbps";
tSCC    zMbps_NAME[]               = "MBPS";
tSCC    zMbps_Name[]               = "mbps";
static const int
    aMbpsCantList[] = {
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define MBPS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_STRING))

/*
 *  Topspeed option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zTopspeedText[] =
        "Replay packets as fast as possible";
tSCC    zTopspeed_NAME[]           = "TOPSPEED";
tSCC    zTopspeed_Name[]           = "topspeed";
static const int
    aTopspeedCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_PPS,
    INDEX_OPT_ONEATATIME, NO_EQUIVALENT };
#define TOPSPEED_FLAGS       (OPTST_DISABLED)

/*
 *  Oneatatime option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zOneatatimeText[] =
        "Replay one packet at a time for each user input";
tSCC    zOneatatime_NAME[]         = "ONEATATIME";
tSCC    zOneatatime_Name[]         = "oneatatime";
static const int
    aOneatatimeCantList[] = {
    INDEX_OPT_MBPS,
    INDEX_OPT_PPS,
    INDEX_OPT_MULTIPLIER,
    INDEX_OPT_TOPSPEED, NO_EQUIVALENT };
#define ONEATATIME_FLAGS       (OPTST_DISABLED)

/*
 *  Pps_Multi option description with
 *  "Must also have options" and "Incompatible options":
 */
tSCC    zPps_MultiText[] =
        "Number of packets to send for each time interval";
tSCC    zPps_Multi_NAME[]          = "PPS_MULTI";
tSCC    zPps_Multi_Name[]          = "pps-multi";
#define zPps_MultiDefaultArg         ((char const*)1)
static const int
    aPps_MultiMustList[] = {
    INDEX_OPT_PPS, NO_EQUIVALENT };
#define PPS_MULTI_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Netmap option description:
 */
tSCC    zNetmapText[] =
        "Write packets directly to netmap enabled network adapter";
tSCC    zNetmap_NAME[]             = "NETMAP";
tSCC    zNetmap_Name[]             = "netmap";
#define NETMAP_FLAGS       (OPTST_DISABLED)

/*
 *  Pid option description:
 */
tSCC    zPidText[] =
        "Print the PID of tcpreplay at startup";
tSCC    zPid_NAME[]                = "PID";
tSCC    zPid_Name[]                = "pid";
#define PID_FLAGS       (OPTST_DISABLED)

/*
 *  Stats option description:
 */
tSCC    zStatsText[] =
        "Print statistics every X seconds";
tSCC    zStats_NAME[]              = "STATS";
tSCC    zStats_Name[]              = "stats";
#define STATS_FLAGS       (OPTST_DISABLED \
        | OPTST_SET_ARGTYPE(OPARG_TYPE_NUMERIC))

/*
 *  Version option description:
 */
tSCC    zVersionText[] =
        "Print version information";
tSCC    zVersion_NAME[]            = "VERSION";
tSCC    zVersion_Name[]            = "version";
#define VERSION_FLAGS       (OPTST_DISABLED)

/*
 *  Less_Help option description:
 */
tSCC    zLess_HelpText[] =
        "Display less usage information and exit";
tSCC    zLess_Help_NAME[]          = "LESS_HELP";
tSCC    zLess_Help_Name[]          = "less-help";
#define LESS_HELP_FLAGS       (OPTST_DISABLED | OPTST_IMM)

/*
 *  Help/More_Help option descriptions:
 */
tSCC zHelpText[]          = "Display extended usage information and exit";
tSCC zHelp_Name[]         = "help";
#ifdef HAVE_WORKING_FORK
#define OPTST_MORE_HELP_FLAGS   (OPTST_IMM | OPTST_NO_INIT)
tSCC zMore_Help_Name[]    = "more-help";
tSCC zMore_HelpText[]     = "Extended usage information passed thru pager";
#else
#define OPTST_MORE_HELP_FLAGS   (OPTST_OMITTED | OPTST_NO_INIT)
#define zMore_Help_Name   NULL
#define zMore_HelpText    NULL
#endif
tSCC zSave_OptsText[]     = "Save the option state to a config file";
tSCC zSave_Opts_Name[]    = "save-opts";
tSCC zLoad_OptsText[]     = "Load options from a config file";
tSCC zLoad_Opts_NAME[]    = "LOAD_OPTS";
tSCC zNotLoad_Opts_Name[] = "no-load-opts";
tSCC zNotLoad_Opts_Pfx[]  = "no";
#define zLoad_Opts_Name   (zNotLoad_Opts_Name + 3)
/*
 *  Declare option callback procedures
 */
#ifdef DEBUG
  static tOptProc doOptDbug;
#else /* not DEBUG */
# define doOptDbug NULL
#endif /* def/not DEBUG */
#ifdef ENABLE_PCAP_FINDALLDEVS
  static tOptProc doOptListnics;
#else /* not ENABLE_PCAP_FINDALLDEVS */
# define doOptListnics NULL
#endif /* def/not ENABLE_PCAP_FINDALLDEVS */
extern tOptProc
    optionNumericVal, optionPagedUsage;
static tOptProc
    doOptLess_Help, doOptLimit,     doOptLoop,      doOptPid,
    doOptPps_Multi, doOptStats,     doOptVersion,   doUsageOpt;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay Option Descriptions.
 */
static tOptDesc optDesc[ OPTION_CT ] = {
  {  /* entry idx, value */ 0, VALUE_OPT_DBUG,
     /* equiv idx, value */ 0, VALUE_OPT_DBUG,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DBUG_FLAGS, 0,
     /* last opt argumnt */ { zDbugDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptDbug,
     /* desc, NAME, name */ zDbugText, zDbug_NAME, zDbug_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 1, VALUE_OPT_QUIET,
     /* equiv idx, value */ 1, VALUE_OPT_QUIET,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ QUIET_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zQuietText, zQuiet_NAME, zQuiet_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 2, VALUE_OPT_TIMER,
     /* equiv idx, value */ 2, VALUE_OPT_TIMER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TIMER_FLAGS, 0,
     /* last opt argumnt */ { zTimerDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTimerText, zTimer_NAME, zTimer_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 3, VALUE_OPT_SLEEP_ACCEL,
     /* equiv idx, value */ 3, VALUE_OPT_SLEEP_ACCEL,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ SLEEP_ACCEL_FLAGS, 0,
     /* last opt argumnt */ { zSleep_AccelDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zSleep_AccelText, zSleep_Accel_NAME, zSleep_Accel_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 4, VALUE_OPT_RDTSC_CLICKS,
     /* equiv idx, value */ 4, VALUE_OPT_RDTSC_CLICKS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ RDTSC_CLICKS_FLAGS, 0,
     /* last opt argumnt */ { zRdtsc_ClicksDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zRdtsc_ClicksText, zRdtsc_Clicks_NAME, zRdtsc_Clicks_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 5, VALUE_OPT_VERBOSE,
     /* equiv idx, value */ 5, VALUE_OPT_VERBOSE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERBOSE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zVerboseText, zVerbose_NAME, zVerbose_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 6, VALUE_OPT_DECODE,
     /* equiv idx, value */ 6, VALUE_OPT_DECODE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DECODE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDecodeMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDecodeText, zDecode_NAME, zDecode_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 7, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equiv idx, value */ 7, VALUE_OPT_ENABLE_FILE_CACHE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ENABLE_FILE_CACHE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aEnable_File_CacheMustList, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zEnable_File_CacheText, zEnable_File_Cache_NAME, zEnable_File_Cache_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 8, VALUE_OPT_PRELOAD_PCAP,
     /* equiv idx, value */ 8, VALUE_OPT_PRELOAD_PCAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PRELOAD_PCAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPreload_PcapText, zPreload_Pcap_NAME, zPreload_Pcap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 9, VALUE_OPT_CACHEFILE,
     /* equiv idx, value */ 9, VALUE_OPT_CACHEFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ CACHEFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aCachefileMustList, aCachefileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zCachefileText, zCachefile_NAME, zCachefile_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 10, VALUE_OPT_DUALFILE,
     /* equiv idx, value */ 10, VALUE_OPT_DUALFILE,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ DUALFILE_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aDualfileMustList, aDualfileCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zDualfileText, zDualfile_NAME, zDualfile_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 11, VALUE_OPT_INTF1,
     /* equiv idx, value */ 11, VALUE_OPT_INTF1,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 1, 1, 0,
     /* opt state flags  */ INTF1_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf1Text, zIntf1_NAME, zIntf1_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 12, VALUE_OPT_INTF2,
     /* equiv idx, value */ 12, VALUE_OPT_INTF2,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ INTF2_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zIntf2Text, zIntf2_NAME, zIntf2_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 13, VALUE_OPT_LISTNICS,
     /* equiv idx, value */ 13, VALUE_OPT_LISTNICS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LISTNICS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptListnics,
     /* desc, NAME, name */ zListnicsText, zListnics_NAME, zListnics_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 14, VALUE_OPT_LOOP,
     /* equiv idx, value */ 14, VALUE_OPT_LOOP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LOOP_FLAGS, 0,
     /* last opt argumnt */ { zLoopDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLoop,
     /* desc, NAME, name */ zLoopText, zLoop_NAME, zLoop_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 15, VALUE_OPT_PKTLEN,
     /* equiv idx, value */ 15, VALUE_OPT_PKTLEN,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PKTLEN_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zPktlenText, zPktlen_NAME, zPktlen_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 16, VALUE_OPT_LIMIT,
     /* equiv idx, value */ 16, VALUE_OPT_LIMIT,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LIMIT_FLAGS, 0,
     /* last opt argumnt */ { zLimitDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLimit,
     /* desc, NAME, name */ zLimitText, zLimit_NAME, zLimit_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 17, VALUE_OPT_MULTIPLIER,
     /* equiv idx, value */ 17, VALUE_OPT_MULTIPLIER,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MULTIPLIER_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMultiplierCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMultiplierText, zMultiplier_NAME, zMultiplier_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 18, VALUE_OPT_PPS,
     /* equiv idx, value */ 18, VALUE_OPT_PPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aPpsCantList,
     /* option proc      */ optionNumericVal,
     /* desc, NAME, name */ zPpsText, zPps_NAME, zPps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 19, VALUE_OPT_MBPS,
     /* equiv idx, value */ 19, VALUE_OPT_MBPS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ MBPS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aMbpsCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zMbpsText, zMbps_NAME, zMbps_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 20, VALUE_OPT_TOPSPEED,
     /* equiv idx, value */ 20, VALUE_OPT_TOPSPEED,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ TOPSPEED_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aTopspeedCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zTopspeedText, zTopspeed_NAME, zTopspeed_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 21, VALUE_OPT_ONEATATIME,
     /* equiv idx, value */ 21, VALUE_OPT_ONEATATIME,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ ONEATATIME_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, aOneatatimeCantList,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zOneatatimeText, zOneatatime_NAME, zOneatatime_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 22, VALUE_OPT_PPS_MULTI,
     /* equiv idx, value */ 22, VALUE_OPT_PPS_MULTI,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PPS_MULTI_FLAGS, 0,
     /* last opt argumnt */ { zPps_MultiDefaultArg },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ aPps_MultiMustList, NULL,
     /* option proc      */ doOptPps_Multi,
     /* desc, NAME, name */ zPps_MultiText, zPps_Multi_NAME, zPps_Multi_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 23, VALUE_OPT_NETMAP,
     /* equiv idx, value */ 23, VALUE_OPT_NETMAP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ NETMAP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zNetmapText, zNetmap_NAME, zNetmap_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 24, VALUE_OPT_PID,
     /* equiv idx, value */ 24, VALUE_OPT_PID,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ PID_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptPid,
     /* desc, NAME, name */ zPidText, zPid_NAME, zPid_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 25, VALUE_OPT_STATS,
     /* equiv idx, value */ 25, VALUE_OPT_STATS,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ STATS_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptStats,
     /* desc, NAME, name */ zStatsText, zStats_NAME, zStats_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 26, VALUE_OPT_VERSION,
     /* equiv idx, value */ 26, VALUE_OPT_VERSION,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ VERSION_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptVersion,
     /* desc, NAME, name */ zVersionText, zVersion_NAME, zVersion_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ 27, VALUE_OPT_LESS_HELP,
     /* equiv idx, value */ 27, VALUE_OPT_LESS_HELP,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ LESS_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doOptLess_Help,
     /* desc, NAME, name */ zLess_HelpText, zLess_Help_NAME, zLess_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_HELP, VALUE_OPT_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_IMM | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ doUsageOpt,
     /* desc, NAME, name */ zHelpText, NULL, zHelp_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_MORE_HELP, VALUE_OPT_MORE_HELP,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_MORE_HELP_FLAGS, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ optionPagedUsage,
     /* desc, NAME, name */ zMore_HelpText, NULL, zMore_Help_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_SAVE_OPTS, VALUE_OPT_SAVE_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, 1, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
                          | OPTST_ARG_OPTIONAL | OPTST_NO_INIT, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL,  NULL,
     /* option proc      */ NULL,
     /* desc, NAME, name */ zSave_OptsText, NULL, zSave_Opts_Name,
     /* disablement strs */ NULL, NULL },

  {  /* entry idx, value */ INDEX_OPT_LOAD_OPTS, VALUE_OPT_LOAD_OPTS,
     /* equiv idx value  */ NO_EQUIVALENT, 0,
     /* equivalenced to  */ NO_EQUIVALENT,
     /* min, max, act ct */ 0, NOLIMIT, 0,
     /* opt state flags  */ OPTST_SET_ARGTYPE(OPARG_TYPE_STRING)
			  | OPTST_DISABLE_IMM, 0,
     /* last opt argumnt */ { NULL },
     /* arg list/cookie  */ NULL,
     /* must/cannot opts */ NULL, NULL,
     /* option proc      */ optionLoadOpt,
     /* desc, NAME, name */ zLoad_OptsText, zLoad_Opts_NAME, zLoad_Opts_Name,
     /* disablement strs */ zNotLoad_Opts_Name, zNotLoad_Opts_Pfx }
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *  Define the Tcpreplay Option Environment
 */
tSCC   zPROGNAME[]   = "TCPREPLAY";
tSCC   zUsageTitle[] =
"tcpreplay (tcpreplay) - Replay network traffic stored in pcap files\n\
USAGE:  %s [ -<flag> [<val>] | --<name>[{=| }<val>] ]... <pcap_file(s)>\n";
tSCC   zRcName[]     = ".tcpreplayrc";
tSCC*  apzHomeList[] = {
       "$$/",
       NULL };

tSCC   zBugsAddr[]    = "tcpreplay-users@lists.sourceforge.net";
tSCC   zExplain[]     = "\n\
tcpreplay is a tool for replaying network traffic from files saved with\n\
tcpdump or other tools which write pcap(3) files.\n";
tSCC    zDetail[]     = "\n\
The basic operation of tcpreplay is to resend  all  packets  from  the\n\
input file(s) at the speed at which they were recorded, or a specified \n\
data rate, up to as fast as the hardware is capable.\n\n\
Optionally, the traffic can be split between two interfaces, written to\n\
files, filtered and edited in various ways, providing the means to test\n\
firewalls, NIDS and other network devices.\n\n\
For more details, please see the Tcpreplay Manual at:\n\
http://tcpreplay.synfin.net/wiki/manual\n";
#define zFullVersion    NULL
/* extracted from /usr/share/autogen/optcode.tpl near line 495 */

#if defined(ENABLE_NLS)
# define OPTPROC_BASE OPTPROC_TRANSLATE
  static tOptionXlateProc translate_option_strings;
#else
# define OPTPROC_BASE OPTPROC_NONE
# define translate_option_strings NULL
#endif /* ENABLE_NLS */


#define tcpreplay_full_usage NULL
#define tcpreplay_short_usage NULL
tOptions tcpreplayOptions = {
    OPTIONS_STRUCT_VERSION,
    0, NULL,                    /* original argc + argv    */
    ( OPTPROC_BASE
    + OPTPROC_ERRSTOP
    + OPTPROC_SHORTOPT
    + OPTPROC_LONGOPT
    + OPTPROC_NO_REQ_OPT
    + OPTPROC_ARGS_REQ
    + OPTPROC_GNUUSAGE ),
    0, NULL,                    /* current option index, current option */
    NULL,         NULL,         zPROGNAME,
    zRcName,      zCopyright,   zCopyrightNotice,
    zFullVersion, apzHomeList,  zUsageTitle,
    zExplain,     zDetail,      optDesc,
    zBugsAddr,                  /* address to send bugs to */
    NULL, NULL,                 /* extensions/saved state  */
    optionUsage,       /* usage procedure */
    translate_option_strings,   /* translation procedure */
    /*
     *  Indexes to special options
     */
    { INDEX_OPT_MORE_HELP, /* more-help option index */
      INDEX_OPT_SAVE_OPTS, /* save option index */
      NO_EQUIVALENT, /* '-#' option index */
      NO_EQUIVALENT /* index of default opt */
    },
    32 /* full option count */, 28 /* user option count */,
    tcpreplay_full_usage, tcpreplay_short_usage,
    NULL, NULL
};

/*
 *  Create the static procedure(s) declared above.
 */
static void
doUsageOpt(
    tOptions*   pOptions,
    tOptDesc*   pOptDesc )
{
    (void)pOptions;
    USAGE( EXIT_SUCCESS );
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the dbug option, when DEBUG is #define-d.
 */
#ifdef DEBUG
static void
doOptDbug(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, 5 } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}
#endif /* defined DEBUG */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the listnics option, when ENABLE_PCAP_FINDALLDEVS is #define-d.
 */
#ifdef ENABLE_PCAP_FINDALLDEVS
static void
doOptListnics(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 312 */

    interface_list_t *list = get_interface_list();
    list_interfaces(list);
    free(list);
    exit(0);

}
#endif /* defined ENABLE_PCAP_FINDALLDEVS */

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the loop option.
 */
static void
doOptLoop(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 0, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the limit option.
 */
static void
doOptLimit(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pps-multi option.
 */
static void
doOptPps_Multi(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the pid option.
 */
static void
doOptPid(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 478 */

    fprintf(stderr, "PID: %d\n", getpid());

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the stats option.
 */
static void
doOptStats(tOptions* pOptions, tOptDesc* pOptDesc)
{
    static const struct {long const rmin, rmax;} rng[1] = {
        { 1, LONG_MAX } };
    long val;
    int  ix;
    char * pzEnd;

    if (pOptions <= OPTPROC_EMIT_LIMIT)
        goto emit_ranges;

    errno = 0;
    val = strtol(pOptDesc->optArg.argString, &pzEnd, 0);
    if ((pOptDesc->optArg.argString == pzEnd) || (errno != 0))
        goto bad_value;

    if (*pzEnd != '\0')
        goto bad_value;
    for (ix = 0; ix < 1; ix++) {
        if (val < rng[ix].rmin)
            continue;  /* ranges need not be ordered. */
        if (val == rng[ix].rmin)
            goto valid_return;
        if (rng[ix].rmax == LONG_MIN)
            continue;
        if (val <= rng[ix].rmax)
            goto valid_return;
    }

  bad_value:

    option_usage_fp = stderr;

  emit_ranges:
    optionShowRange(pOptions, pOptDesc, (void *)rng, 1);
    return;

  valid_return:
    if ((pOptDesc->fOptState & OPTST_ALLOC_ARG) != 0) {
        free((void *)pOptDesc->optArg.argString);
        pOptDesc->fOptState &= ~OPTST_ALLOC_ARG;
    }
    pOptDesc->optArg.argInt = val;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the version option.
 */
static void
doOptVersion(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 501 */

    fprintf(stderr, "tcpreplay version: %s (build %s)", VERSION, git_version());
#ifdef DEBUG
    fprintf(stderr, " (debug)");
#endif
    fprintf(stderr, "\n");
    fprintf(stderr, "Copyright 2000-2010 by Aaron Turner <aturner at synfin dot net>\n");
    fprintf(stderr, "The entire Tcpreplay Suite is licensed under the GPLv3\n");
    fprintf(stderr, "Cache file supported: %s\n", CACHEVERSION);
#ifdef HAVE_LIBDNET
    fprintf(stderr, "Compiled against libdnet: %s\n", LIBDNET_VERSION);
#else
    fprintf(stderr, "Not compiled with libdnet.\n");
#endif
#ifdef HAVE_WINPCAP
    fprintf(stderr, "Compiled against winpcap: %s\n", get_pcap_version());
#else
    fprintf(stderr, "Compiled against libpcap: %s\n", get_pcap_version());
#endif
#ifdef ENABLE_64BITS
    fprintf(stderr, "64 bit packet counters: enabled\n");
#else
    fprintf(stderr, "64 bit packet counters: disabled\n");
#endif
#ifdef ENABLE_VERBOSE
    fprintf(stderr, "Verbose printing via tcpdump: enabled\n");
#else
    fprintf(stderr, "Verbose printing via tcpdump: disabled\n");
#endif
#ifdef TCPREPLAY_EDIT
    fprintf(stderr, "Packet editing: enabled\n");
#else
    fprintf(stderr, "Packet editing: disabled\n");
#endif
#ifdef ENABLE_FRAGROUTE
    fprintf(stderr, "Fragroute engine: enabled\n");
#else
    fprintf(stderr, "Fragroute engine: disabled\n");
#endif
#ifdef HAVE_NETMAP
    fprintf(stderr, "Default injection method: %s\n", sendpacket_get_method());
    fprintf(stderr, "Optional injection method: netmap\n");
#else
    fprintf(stderr, "Injection method: %s\n", sendpacket_get_method());
#endif
    exit(0);

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *
 *   For the less-help option.
 */
static void
doOptLess_Help(tOptions* pOptions, tOptDesc* pOptDesc)
{
    /* extracted from tcpreplay_opts.def, line 558 */

    USAGE(EXIT_FAILURE);

}
/* extracted from /usr/share/autogen/optcode.tpl near line 627 */

#if ENABLE_NLS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <autoopts/usage-txt.h>

static char* AO_gettext( char const* pz );
static void  coerce_it(void** s);

static char*
AO_gettext( char const* pz )
{
    char* pzRes;
    if (pz == NULL)
        return NULL;
    pzRes = _(pz);
    if (pzRes == pz)
        return pzRes;
    pzRes = strdup( pzRes );
    if (pzRes == NULL) {
        fputs( _("No memory for duping translated strings\n"), stderr );
        exit( EXIT_FAILURE );
    }
    return pzRes;
}

static void coerce_it(void** s) { *s = AO_gettext(*s); }
#define COERSION(_f) \
  coerce_it((void*)&(tcpreplayOptions._f))

/*
 *  This invokes the translation code (e.g. gettext(3)).
 */
static void
translate_option_strings( void )
{
    /*
     *  Guard against re-translation.  It won't work.  The strings will have
     *  been changed by the first pass through this code.  One shot only.
     */
    if (option_usage_text.field_ct != 0) {

        /*
         *  Do the translations.  The first pointer follows the field count
         *  field.  The field count field is the size of a pointer.
         */
        tOptDesc* pOD = tcpreplayOptions.pOptDesc;
        char**    ppz = (char**)(void*)&(option_usage_text);
        int       ix  = option_usage_text.field_ct;

        do {
            ppz++;
            *ppz = AO_gettext(*ppz);
        } while (--ix > 0);

        COERSION(pzCopyright);
        COERSION(pzCopyNotice);
        COERSION(pzFullVersion);
        COERSION(pzUsageTitle);
        COERSION(pzExplain);
        COERSION(pzDetail);
        option_usage_text.field_ct = 0;

        for (ix = tcpreplayOptions.optCt; ix > 0; ix--, pOD++)
            coerce_it((void*)&(pOD->pzText));
    }

    if ((tcpreplayOptions.fOptSet & OPTPROC_NXLAT_OPT_CFG) == 0) {
        tOptDesc* pOD = tcpreplayOptions.pOptDesc;
        int       ix;

        for (ix = tcpreplayOptions.optCt; ix > 0; ix--, pOD++) {
            coerce_it((void*)&(pOD->pz_Name));
            coerce_it((void*)&(pOD->pz_DisableName));
            coerce_it((void*)&(pOD->pz_DisablePfx));
        }
        /* prevent re-translation */
        tcpreplayOptions.fOptSet |= OPTPROC_NXLAT_OPT_CFG | OPTPROC_NXLAT_OPT;
    }
}

#endif /* ENABLE_NLS */

#ifdef  __cplusplus
}
#endif
/* tcpreplay_opts.c ends here */
